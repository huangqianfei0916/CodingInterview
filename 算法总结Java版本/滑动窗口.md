* 滑动窗口
* [滑动窗口的最大值](#1)
*  [最短无序连续子数组](#2)
*  [和为S的连续正数序列](#3)
* [数字在排序数组中出现的次数](#4)
* [旋转数组的最小数字](#5)
* 3sum
*********
<h4 id="1">滑动窗口的最大值</h4>

*****
给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。
* 双端队列
* 队列第一个位置保存当前窗口的最大值;
* 新增加的值从队尾开始比较，把所有比他小的值丢掉,之后再增加，若是先增加再删除就是自己和自己比了。
* 判断当前最大值是否过期
* 长度一旦达到size，每个循环用ArrayList存储最大值；
```java
import java.util.*;
public class Solution {
    public ArrayList<Integer> maxInWindows(int [] num, int size)
    {
        ArrayList <Integer>list=new ArrayList();
        if(size==0){
            return list;
        }
        LinkedList <Integer>q=new LinkedList();
        
        for(int i=0;i<num.length;i++){
            //保证队列头始终为最大的
            while(q.size()!=0&&num[q.peekLast()]<num[i]){
                q.pollLast();
            }
            q.addLast(i);
            //判断前面的值是否过期
            if(q.peekFirst()==i-size){
                q.pollFirst();
            }
            //从size-1开始每移动一下添加一个最大值
            if(i>=size-1){
                list.add(num[q.peekFirst()]);
            }
        }
        return list;
    }
}
```
*************

<h4 id="2">最短无序连续子数组</h4>

给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。

你找到的子数组应是最短的，请输出它的长度。

示例 1:

输入: [2, 6, 4, 8, 10, 9, 15]
输出: 5
解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。

* 先排序；将排序数组和原数组分别两边对比；
* l==r: return 0; 否则 返回（r-l）+1;
```java
class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int clone[]=nums.clone();
        Arrays.sort(nums);
        int l=0;
        int r=nums.length-1;
        boolean left=false;
        boolean right=false;
        while(l<r){
            if(nums[l]==clone[l]){
                l++;
            }else{
                left=true;
            }
            if(nums[r]==clone[r]){
                r--;
            }else{
                right=true;
            }
            if(left&&right){
                break;
            }
        }
        if(l==r){
            return 0;
        }else{
            return r-l+1;
        }
    }
}
```
*********
<h4 id="3">和为S的连续正数序列</h4>
小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!

* mid为跳出条件，当a大于mid，a+b>sum;
* 当相等时将[a,b]添加；继续增加b；
* 小于增加b；大于增加a；

```java
import java.util.ArrayList;
public class Solution {
    public ArrayList<ArrayList<Integer> > FindContinuousSequence(int sum) {
        ArrayList<ArrayList<Integer>> listall=new ArrayList();
        
        int a=1;
        int b=2;
        int cur=a+b;
        int mid=(1+sum)/2;
        
        while(a<=mid){
            if(cur==sum){
                ArrayList list=new ArrayList();
                for(int i=a;i<=b;i++){
                    list.add(i);
                }
                listall.add(list);
                b++;
                cur+=b;
            }else if(cur<sum){
                b++;
                cur+=b;
            }else{
                cur-=a;
                a++;
            }
        }
        return listall;
       
    }
}
```
*****
<h4 id="4">数字在排序数组中出现的次数</h4>

*********
统计一个数字在排序数组中出现的次数。

* 求出最左边的点的下标，再求出最右边点的下标，相减即可。
* 相等时注意边界判断。
```java
public class Solution {
    public int GetNumberOfK(int [] array , int k) {
        
        if(array.length==0){
            return 0;
        }
        int a=getfirst(array,k);
        int b=getlast(array,k);
        int result=0;
        if(a!=-1&&b!=-1){
            result=b-a+1;
        }
        return result;
       
    }
    
    public int getfirst(int [] array,int k){
        int s=0;
        int e=array.length-1;
        int mid=(s+e)/2;
        while(s<=e){
            mid=(s+e)/2;
            if(array[mid]==k){
                if(mid>0&&array[mid-1]!=k||mid==0){
                    return mid;
                }else{
                    e=mid-1;
                }
            }else if(array[mid]<k){
                s=mid+1;
            }else{
                e=mid-1;
            }
        }
        return -1;
        
    }
    
     public int getlast(int [] array,int k){
        int s=0;
        int e=array.length-1;
        int mid=(s+e)/2;
        while(s<=e){
            mid=(s+e)/2;
            if(array[mid]==k){
                if(mid<array.length-1&&array[mid+1]!=k||mid==array.length-1){
                    return mid;
                }else{
                    s=mid+1;
                }
            }else if(array[mid]<k){
                s=mid+1;
            }else{
                e=mid-1;
            }
        }
        return -1; 
    }
}
```
******
<h4 id="5">旋转数组的最小数字</h4>

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
* 注意特殊情况10111
* 注意start=mid；以及end=mid；
* 注意判断时是array[mid]>=array[start]；带上 =；
```java
import java.util.ArrayList;
public class Solution {
public int minNumberInRotateArray(int [] array) {
	      
	        
	        int start=0;
	        int end=array.length-1;
	        int mid=(start+end)/2;
	        while(start<=end){
	           
	            if((end-start)==1){
	                return array[end];
	            }
	            mid=(start+end)/2;
	            if(array[start]==array[end]&&array[mid]==array[end]){
	                return order(array);
	            }
	            if(array[mid]>=array[start]){
	                start=mid;
	            }
	            if(array[mid]<=array[end]){
	                end=mid;
	            }
	        }
	        return 0;
	    
	    }
	    public int order(int [] array){
	        int min=array[0];
	        for(int i=1;i<array.length;i++){
	            if(min>array[i]){
	                min=array[i];
	            }
	        }
	        return min;
	    }
}
```
* 3sum
* 先排序，再从两边判断
```java
import java.util.*;
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> listall=new ArrayList();
        if(nums.length<3){
            return listall;
        }

        Arrays.sort(nums);
        for(int i=0;i<nums.length;i++){
            int l=i+1;
            int r=nums.length-1;
            if(i>0&&nums[i]==nums[i-1]){
                continue;
            }

            while(l<r){
                int sum=nums[i]+nums[l]+nums[r];
                if(sum==0){
                    ArrayList <Integer> list= new ArrayList();
                    list.add(nums[i]);
                    list.add(nums[l]);
                    list.add(nums[r]);
                    listall.add(list);
                    while(l<r&&nums[l]==nums[l+1]){
                        l++;
                    }
                    while(l<r&&nums[r]==nums[r-1]){
                        r--;
                    }
                    l++;
                    r--;
                }else if(sum>0){
                    r--;
                }else{
                    l++;
                }
            }
        }
        return listall;

    }
}
```