### 链表

* [删除链表中重复的结点](#1)
* [链表中环的入口结点](#2)
* [两个链表的第一个公共结点](#3)
* [复杂链表的复制](#4)
* [合并K个排序链表](#5)
* [旋转链表](#6)
* [排序链表](#7)
* 指定区间翻转链表

<h4 id="1">删除链表中重复的结点</h4>

**题目描述**
在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5

* 通过创建头节点来处理一开始就重复；
* flag来判断是不是重复元素的最后一个；
* 分开处理前边和结尾。
```java
public class Solution {
    public ListNode deleteDuplication(ListNode pHead)
    {
        if(pHead==null){
            return null;
        }
        ListNode H=new ListNode(0);
        ListNode pre=H;
        H.next=pHead;
        ListNode p=pHead;
        int flag=0;
        while(p!=null){
            if(p.next!=null){
                if(p.next.val==p.val){
                    pre.next=p.next;
                    p=p.next;
                    flag=1;
                }else{
                    if(flag==1){
                        flag=0;
                        pre.next=p.next;
                        p=p.next;
                    }else{
                        pre=p;
                        p=p.next;
                    }
                }
            }else{
                if(flag==1){
                    pre.next=p.next;
                    p=p.next;
                }else{
                    p=p.next;
                }     
            }
        }
        return H.next;
    }
}
```
*****************
<h4 id="2">链表中环的入口结点</h4>

给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。
* 先利用快慢指针判断是否有环；
* 若存在环，则在走上一圈求环长；
* 利用快慢指针求环入口；
```java
public class Solution {

    public ListNode EntryNodeOfLoop(ListNode pHead)
    {
        if(pHead==null){
            return null;
        }
        ListNode t=meet(pHead);
        if(t==null){
            return null;
        }
        int len=1;
        ListNode p=t;
        while(p.next!=t){
            len++;
            p=p.next;
        }
        
        ListNode f=pHead;
        ListNode e=f;
        for(int i=0;i<len;i++){
            e=e.next;
        }
        while(e!=null){
            if(e==f){
                break;
            }else{
                e=e.next;
                f=f.next;
            }
        }
        return e;
    }
    
    public ListNode meet(ListNode head){
        ListNode p=head.next;
        ListNode q=null;
        if(p!=null){
            q=p.next;
        }
        while(q!=null){
            if(p==q){
                return p;
            }else{
                p=p.next;
                q=q.next;
                if(q!=null){
                    q=q.next;
                }
            }
        }
        return null;
        
    }
}
```
***************
<h4 id="3">两个链表的第一个公共结点</h4>

输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）
* 分别统计两个链表的长度，长的多走差值步，判断是否相遇。
```java
public class Solution {
    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
        if(pHead1==null||pHead2==null){
            return null;
        }
        int len1=0;
        int len2=0;
        ListNode p=pHead1;
        ListNode q=pHead2;
        while(p!=null){
            len1++;
            p=p.next;
        }
        while(q!=null){
            len2++;
            q=q.next;
        }
        int l=Math.abs(len1-len2);
        if(len1>len2){
            for(int i=0;i<l;i++){
                pHead1=pHead1.next;
            }
        }else{
            for(int i=0;i<l;i++){
                pHead2=pHead2.next;
            }
        }
        while(pHead1!=null){
            if(pHead1==pHead2){
                break;
            }else{
                pHead1=pHead1.next;
                pHead2=pHead2.next;
            }
        }
     return pHead1;
    }
}
```
****************
<h4 id="4">复杂链表的复制</h4>


输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）
* 首先将链表的每一个节点复制，插在其对应节点的后面；
* 重新遍历链表，设置随机指针，若存在则设置；不存在则设置null；
* 将两个链表分开；这里对复制链表设置一个clonehead，设置一个clonenode用于遍历。
* 先设置原链表的next，在设置复制链表的next。
```java
public class Solution {
    public RandomListNode Clone(RandomListNode pHead)
    {
        if(pHead==null){
            return null;
        }
        
        RandomListNode p=pHead;
        while(p!=null){
            RandomListNode node=new RandomListNode(p.label);
            node.next=p.next;
            p.next=node;
            p=node.next;
        }
        
        p=pHead;
        while(p!=null){
            if(p.random!=null){
                p.next.random=p.random.next;
                
            }else{
                p.next.random=null;
            }
            p=p.next.next;
        }
        
        p=pHead;
        RandomListNode clonehead=pHead.next;
        RandomListNode clonenode=pHead.next;
        while(p!=null){
            p.next=clonenode.next;
            if(clonenode.next!=null){
                clonenode.next=clonenode.next.next;
            }else{
                clonenode.next=null;
            }
            p=p.next;
            clonenode=clonenode.next;
        }
        return clonehead;
        
    }
}
```
****************
<h4 id="5">合并K个排序的链表</h4>

* 采用分治思想；
* 创建头节点来合并两个链表。
```java
class Solution {
	public ListNode mergeKLists(ListNode[] lists) {
		if(lists.length==0) {
			return null;
		}
		return helper(lists,0,lists.length-1);
	}
	

	private ListNode helper(ListNode[] lists, int begin, int end) {
		if(begin==end) {
			return lists[begin];
		}
		int mid = (end+begin)/2;
		ListNode left = helper(lists,begin,mid);
		ListNode right = helper(lists,mid+1,end);
		return merge(left,right);
	}
	
	//合并两个有序链表
	private ListNode merge(ListNode a, ListNode b) {
        ListNode head=new ListNode(0);
        ListNode p=head;
        while(a!=null&&b!=null){
            if(a.val<b.val){
                p.next=a;
                p=p.next;
                a=a.next;
            }else{
                p.next=b;
                p=p.next;
                b=b.next;
            }
        }
        if(a!=null){
            p.next=a;
        }
        if(b!=null){
            p.next=b;
        }
        return head.next;
	
	}
}
```
*****************
<h4 id="6">旋转链表</h4>

给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。

示例 1:

输入: 1->2->3->4->5->NULL, k = 2
输出: 4->5->1->2->3->NULL
解释:
向右旋转 1 步: 5->1->2->3->4->NULL
向右旋转 2 步: 4->5->1->2->3->NULL

```java
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if(k==0||head==null){
            return head;
        }

        ListNode p=head;
        ListNode pre=p;
        int sum=0;
        while(p!=null){
            sum++;
            pre=p;
            p=p.next;
        }
        k=k%sum;
        pre.next=head;
        int l=Math.abs(sum-k);
        for(int i=0;i<l;i++){
            pre=pre.next;
            head=head.next;
        }
        pre.next=null;
        return head;
    }
}
```
********
<h4 id="7">排序链表</h4>

在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。

示例 1:

输入: 4->2->1->3
输出: 1->2->3->4
示例 2:

输入: -1->5->3->4->0
输出: -1->0->3->4->5

```java
class Solution {
    public ListNode sortList(ListNode head) {
        if(head==null){
            return null;
        }
        ListNode p=head;
        while(p.next!=null){
            p=p.next;
        }
        ListNode f=divide(head,p);
        return f;
    }
    public static ListNode divide(ListNode start, ListNode end) {
        if (start == end) {
            return start;
        }
        int len = len(start, end);
        int mid1 = len / 2;
        ListNode mid = start;
        mid1--;
        while (mid1 != 0) {
            mid1--;
            mid = mid.next;
        }
        ListNode rmid=mid.next;
        mid.next=null;
        ListNode left = divide(start, mid);
        ListNode right = divide(rmid, end);

        return merge(left,right);
    }

    public static int len(ListNode t,ListNode e) {
        int sum = 1;
        while (t != e) {
            sum++;
            t = t.next;
        }
        return sum;
    }

    public static ListNode merge(ListNode A,ListNode B) {
        ListNode H = new ListNode(0);
        ListNode p = H;

        while (A != null && B != null) {
            if (A.val < B.val) {
                p.next = A;
                p = p.next;
                A = A.next;
            } else {
                p.next = B;
                p = p.next;
                B = B.next;
            }
        }

        if (A != null) {
            p.next = A;
        }
        if (B != null) {
            p.next = B;
        }
        return H.next;
    }
}
```

* 指定区间翻转链表
```java
 public ListNode reverse(ListNode head, int m, int n) {
        // write code here
        ListNode h=new ListNode(0);
        h.next=head;
        ListNode pre=h;
        ListNode start=h;
        ListNode tail=h;
        for(int i=0;i<m-1;i++){
            pre=pre.next;
        }
        start=pre.next;
        tail=start.next;
     
        for(int i=m;i<n;i++){
            start.next=tail.next;
            tail.next=pre.next;
            pre.next=tail;
            tail=start.next;
        }
    
        return h.next; 
    } 
```

* 链表中的节点每k个一组翻转

```java
import java.util.*;

public class Solution {
      public ListNode reverseKGroup (ListNode head, int k) {
        // write code here
        if (head == null || head.next == null || k == 1) return head; //这三种情况无需进行反转
        ListNode p = head;
          int len=0;
          while(p!=null){
              len++;
              p=p.next;
          }
          int n=len/k;
          int start=1;
          int end=start+k-1;
          while(n!=0){
              head=reverse(head,start,end);
              start=end+1;
              end=start+k-1;
              n--;
          }
        return head;
    }
}
```

