### 数组相关

* [颠倒二进制](#1)
* [使数组唯一的最小增量](#2)
* [阶乘后的零](#3)
* [Z 字形变换](#4)
* [把数组排成最小的数](#5)
* [下一个排列](#6)
* [买卖股票的最佳时机](#7)
* [长度最小的子数组](#8)
* [序列和](#9)
* [顺时针打印矩阵](#10)
* [扑克牌顺子](#11)
*******
<h4 id="1">颠倒二进制</h4>

颠倒给定的 32 位无符号整数的二进制位。

示例 1：

输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。

res = 20 >> 2; 

20的二进制为 0001 0100，右移2位后为 0000 0101，则结果就为 res = 5;

res = -20 >> 2;

-20的二进制为其正数的补答码加1，即 1110 1011，右移2位后为 1111 1100，结果为版 res = -6;

而对于>>>符号而言：

res = 20 >>> 2; 的结果与 >> 相同；

res = -20 >>> 2;

-20的二进制为 1110 1011，右移2位，此时高位补0，即 0011 1010，结果为 res = 58;

```java
public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        int bit=31;
        int sum=0;
        while(n!=0){
            sum+=(n&1)<<bit;
            n=n>>>1;
            bit--;
        }
        return sum;    
    }
}
```
********
<h4 id="2">使数组唯一的最小增量</h4>
给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。

返回使 A 中的每个值都是唯一的最少操作次数。

示例 1:

输入：[1,2,2]
输出：1
解释：经过一次 move 操作，数组将变为 [1, 2, 3]。

* 先对数组排序
* 将后一个数字变成前一个数字加1；
```java
class Solution {
    public int minIncrementForUnique(int[] A) {   
        int num = 0;
		Arrays.sort(A);
		for (int i = 1; i < A.length; i++) {

			int d = A[i] - A[i - 1];
			if (d > 0) {
				continue;
			} else {
				d = Math.abs(d) + 1;
				num += d;
				A[i] = A[i - 1] + 1;

			}
		}
		System.out.println(num);
		return num;
    }
}
```
*********
<h4 id="3">阶乘后的零</h4>
给定一个整数 n，返回 n! 结果尾数中零的数量。

示例 1:

输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
示例 2:

输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.

leetcode 题解：
* 规律就是每隔 5 个数，出现一个 5，每隔 25 个数，出现 2 个 5，每隔 125 个数，出现 3 个 5... 以此类推。

* 最终 5 的个数就是 n / 5 + n / 25 + n / 125 ...


```java
class Solution {
    public int trailingZeroes(int n) {
       int sum=0;
       while(n>0){
           n=n/5;
           sum+=n;
       }
        return sum;
    }
}
```
********
<h4 id="4">Z 字形变换</h4>

将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 "LEETCODEISHIRING" 行数为 3 时，排列如下：

L   C   I   R
E T O E S I I G
E   D   H   N
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："LCIRETOESIIGEDHN"。

请你实现这个将字符串进行指定行数变换的函数：

string convert(string s, int numRows);
示例 1:

输入: s = "LEETCODEISHIRING", numRows = 3
输出: "LCIRETOESIIGEDHN"

* 利用flag实现在头和尾进行反转；
```java
class Solution {
    public String convert(String s, int numRows) {
        if(numRows<=1){
            return s;
        }

        ArrayList<StringBuilder> list=new ArrayList();
        int k=0;
        int flag=-1;
        for(int i=0;i<numRows;i++){
            list.add(new StringBuilder());
        }
        for(int i=0;i<s.length();i++){
            list.get(k).append(s.charAt(i));
            if(k==0||k==numRows-1){
                flag=-flag;
            }
            k+=flag;
        }
        StringBuilder sb=new StringBuilder();
        for(int l=0;l<list.size();l++){
            sb.append(list.get(l));
        }
        return sb.toString();

    }
}
```
*****
<h4 id="5">把数组排成最小的数</h4>

**题目描述**
输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。

```java
import java.util.ArrayList;
public class Solution {
    public String PrintMinNumber(int [] numbers) {
        if(numbers.length==0){
            return "";
        }
        String str="";
        for(int i=0;i<numbers.length;i++){
            for(int j=i+1;j<numbers.length;j++){
                int a= Integer.valueOf(numbers[i]+""+numbers[j]);
                int b= Integer.valueOf(numbers[j]+""+numbers[i]);
                if(a>b){
                    int temp=numbers[i];
                    numbers[i]=numbers[j];
                    numbers[j]=temp;
                }
            }
        }
        for(int i=0;i<numbers.length;i++){
            str+=String.valueOf(numbers[i]);
        }
        return str;
    }
}
```
********
<h4 id="6">下一个排列</h4>

**题目描述**
实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1

* 从右到左 寻找nums[i]>nums[i-1];
* 若最终i=0也就是没找到；就返回直接全部翻转就是最小值了。
* 找到之后，再从右向左寻找第一个大于nums[i-1]的，将nums[i-1]和nums[j]交换；
* 将i-1之后的序列翻转则结束。
```java
class Solution {
    public void nextPermutation(int[] nums) {
    
      int i = nums.length - 1;
		for (; i >= 1; i--) {
			if (nums[i] > nums[i - 1]) {
				break;
			}
		}
		if (i >= 1) {
			int j = nums.length-1;
			for (; j >= i; j--) {
				if (nums[j] > nums[i - 1]) {
					break;
				}
			}
			swap(nums, i - 1, j);
			reverse(nums, i, nums.length - 1);
		} else {
			reverse(nums, 0, nums.length - 1);
		}

    }

    public void reverse(int d[], int l, int r) {
		while (l < r) {
			int temp = d[l];
			d[l] = d[r];
			d[r] = temp;
			l++;
			r--;
		}

	}

	public void swap(int[] d, int i, int j) {
		int temp = d[i];
		d[i] = d[j];
		d[j] = temp;
	}
}
```
*********
<h4 id="7">买卖股票的最佳时机</h4>

**************
**题目描述**
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。

输入: [7,1,5,3,6,4]
输出: 5

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length==0){
            return 0;
        }
        int sum=0;
        int min=prices[0];
        for(int i=0;i<prices.length;i++){
            if(min>prices[i]){
                min=prices[i];
            }
            if(prices[i]-min>sum){
                sum=prices[i]-min;
            }
        }
        return sum;

    }
}
```
* 当可以买卖多次的时候，只要后一项大于前一项就加上其差值；

示例 1:
输入: [7,1,5,3,6,4]
输出: 7
 5-1 = 4 。
 6-3 = 3 


```java
class Solution {
    public int maxProfit(int[] prices) {
        int sum=0;

        for(int i=0;i<prices.length-1;i++){
            if(prices[i+1]>prices[i]){
                sum+=prices[i+1]-prices[i];
            }
        }
        return sum;
        
    }
}
```

*******

<h4 id="8">长度最小的子数组</h4>

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。

示例: 

输入: s = 7, nums = [2,3,1,2,4,3]
输出: 2
解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。

* 一般求求最长最短最大最小都会用到max或者min；
```java
class Solution {
    public int minSubArrayLen(int s, int[] nums) {

        int sum=0;
        int l=Integer.MAX_VALUE;
        int k=0;
        for(int i=0;i<nums.length;i++){
            sum+=nums[i];
            while(sum>=s){
                l=Math.min(l,i+1-k);
                sum-=nums[k++];
            }
        }
        if(l==Integer.MAX_VALUE){
            l=0;
        }
        return l;
    }
}
```
*******

<h4 id="9">序列和</h4>

**题目描述**
给出一个正整数N和长度L，找出一段长度大于等于L的连续非负整数，他们的和恰好为N。答案可能有多个，我我们需要找出长度最小的那个。
例如 N = 18 L = 2：
5 + 6 + 7 = 18
3 + 4 + 5 + 6 = 18
都是满足要求的，但是我们输出更短的 5 6 7
**输入描述:**
输入数据包括一行： 两个正整数N(1 ≤ N ≤ 1000000000),L(2 ≤ L ≤ 100)
**输出描述:**
从小到大输出这段连续非负整数，以空格分隔，行末无空格。如果没有这样的序列或者找出的序列长度大于100，则输出No

```java
import java.util.*;
public class Main{
    public static void main(String []args){
        Scanner sc=new Scanner(System.in);
        int N=sc.nextInt();
        int L=sc.nextInt();
        for(int i=L;i<=100;i++){
            if((2*N-i*i+i)%(2*i)==0){
                int start=(2*N-i*i+i)/(2*i);
                int k=0;
                for(;k<i-1;k++){
                    System.out.print(start+k+" ");
                }
                System.out.print(start+k);
                return;
            }
        }
        System.out.print("No");
    }
}
```
*******
<h4 id="9">顺时针打印矩阵</h4>

**题目描述**
输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.

```java
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printMatrix(int [][] matrix) {
        ArrayList <Integer> list=new ArrayList();
        
        if(matrix.length==0){
            return list;
        }
        int left=0;
        int top=0;
        int right=matrix[0].length-1;
        int bottom=matrix.length-1;
        while(left<=right&&top<=bottom){
            
            for(int i=left;i<=right;i++){
                list.add(matrix[top][i]);
            }
            for(int i=top+1;i<=bottom;i++){
                list.add(matrix[i][right]);
            }
            if(top!=bottom)
            for(int i=right-1;i>=left;i--){
                list.add(matrix[bottom][i]);
            }
            if(left!=right)
            for(int i=bottom-1;i>top;i--){
                list.add(matrix[i][left]);
            }
            top++; left++;
            right--; bottom--;
        }
        return list;
       
    }
}
```
*****
<h4 id="11">扑克牌顺子</h4>

* 先对数组排序；
* 统计0（也就是大小王的个数）;
* 统计两两数字的间隔；
* 判断大小王的数量和间隔的数量；


```java
import java.util.Arrays;
public class Solution {
    public boolean isContinuous(int [] numbers) {
         
        if(numbers.length==0){
            return false;
        }
        Arrays.sort(numbers);
        int num0=0;
        int i=0;
        for(;i<numbers.length;i++){
            if(numbers[i]==0){
                num0++;
            }else{
                break;
            }
        }
        int gap=0;
        int j=i;
         
        for(;j<numbers.length-1;j++){
            if(numbers[j]==numbers[j+1]){
                return false;
            }else{
                gap+=(numbers[j+1]-numbers[j]-1);
            }
             
        }
        boolean flag=false;
        if(num0>=gap){
            flag=true;
        }
        return flag;
 
    }
}
```