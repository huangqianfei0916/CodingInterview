## 排列组合（回朔）

#### 回朔算法框架

* 在dfs标记中，排列选择begin，组合选择i；

* 组合涉及到重复使用和原始数据重复的问题；
* 组合的各个问题先对原数组进行排序，是为了优化剪枝；

*****

* 排列只涉及原始数据重复的问题；

```java
private void dfs(int[] candidates,int len,int residue,int begin) {

        if(residue==0){//终止条件
            res.add(new ArrayList(path));
            return;
        }
        for (int i=begin;i<len;i++){
            //过滤条件
            if(residue-candidates[i]<0){
                break;
            }
            path.add(candidates[i]);
            dfs(candidates,len,residue-candidates[i],i);
            path.remove(path.size()-1);
        }
    }
```
*********

### 解析组合问题

#### 组合case1:原数组无重复元素+每个元素可重复使用->LeetCode-39
给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 .
candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。 

* 先对原数组进行排序；
* target==0；时候退出；
* 只是在递归时候begin对应的i不变；
```java
package com.hqf.backtrack;
import  java.util.*;
public class LeetCode39 {
    List<List<Integer>> res=new ArrayList<>();
    ArrayList<Integer> path=new ArrayList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {

        Arrays.sort(candidates);
        int len=candidates.length;
        dfs(candidates,len,target,0);
        System.out.println(res);
        return res;
    }
    private void dfs(int[] candidates,int len,int residue,int begin) {

        if(residue==0){
            res.add(new ArrayList(path));
            return;
        }
        for (int i=begin;i<len;i++){
            if(residue-candidates[i]<0){
                break;
            }
            path.add(candidates[i]);
            dfs(candidates,len,residue-candidates[i],i);
            path.remove(path.size()-1);
        }
    }
}

```
#### 组合case2:原数组无重复元素+每个元素不可重复使用

* 这里和上面的唯一的区别在于递归时候i+1；（防止同一位置元素重复使用）
```java
private void dfs(int[] candidates,int len,int residue,int begin) {

        if(residue==0){
            res.add(new ArrayList(path));
            return;
        }
        for (int i=begin;i<len;i++){
            if(residue-candidates[i]<0){
                break;
            }
            path.add(candidates[i]);
            dfs(candidates,len,residue-candidates[i],i+1);
            path.remove(path.size()-1);
        }
    }
```
### 组合case3:原数组有重复元素+每个元素不可重复使用->LeetCode40
* 同样的不可重复使用，递归时候i+1；
* 其次因为原数组可能重复，则多了candidates[i] == candidates[i - 1]判断，这个判断去除了相同的分支；
* 又因为上一过滤条件过于强，增加了i > begin，从而得到合理解；
```java
 private void dfs(int[] candidates,int len,int residue,int begin) {

        if(residue==0){
            res.add(new ArrayList(path));
            return;
        }
        for (int i=begin;i<len;i++){
            if(residue-candidates[i]<0){
                break;
            }
            if (i > begin && candidates[i] == candidates[i - 1]) {
                continue;
            }
            path.add(candidates[i]);
            dfs(candidates,len,residue-candidates[i],i+1);
            path.remove(path.size()-1);
        }
    }
```

**************
### 解析排列问题
#### 排列case1:无重复序列的全排列->LeetCode46

* 这里的list.contains(nums[i])是为了避免对同元素的重复使用；
* 因为这里是排列，就必然不能重复使用同一元素了；

```java
class Solution {
    List<List<Integer>> listall=new ArrayList();
    List<Integer>list=new ArrayList();
    public List<List<Integer>> permute(int[] nums) {
        backtrack(nums);
        return listall;
    }
    public void backtrack(int [] nums){
        if(list.size()==nums.length){
            listall.add(new ArrayList(list));
            return;
        }
        for(int i=0;i<nums.length;i++){
            if(!list.contains(nums[i])){
                list.add(nums[i]);
                backtrack(nums);
                list.remove(list.size()-1);
            }
        }

    }
}
```
#### 排列case2: 可重复序列的全排列->LeetCode47

* 这里的vis同样是避免对同一元素的重复使用；
* 相比46多了一个条件
```
if(i>0&&nums[i]==nums[i-1]&&!vis[i-1]){
        continue;
}
```
```java
class Solution {
 List<List<Integer>> listall=new ArrayList<>();
    List<Integer> list=new ArrayList<>();
    boolean[] vis;
    public List<List<Integer>> permuteUnique(int[] nums) {
        int len=nums.length;
        Arrays.sort(nums);
        vis=new boolean[len];
        for(int i=0;i<len;i++){
            vis[i]=false;
        }
        backtrack(nums);
        return listall;

    }
    public void backtrack(int[] nums){
        if(list.size()==nums.length){
            listall.add(new ArrayList<>(list));
            return;
        }
        for(int i=0;i<nums.length;i++){
            if(vis[i]==true){
                continue;
            }
            if(i>0&&nums[i]==nums[i-1]&&!vis[i-1]){
                continue;
            }
            vis[i]=true;
            list.add(nums[i]);
            backtrack(nums);
            list.remove(list.size()-1);
            vis[i]=false;
        }

    }
}
```
### 解析子集问题
#### 子集case1: 78 子集

给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]

说明：解集不能包含重复的子集。
```java
class Solution {
  
  List<List<Integer>> listall=new ArrayList<>();
    int len;
    public List<List<Integer>> subsets(int[] nums) {
        len=nums.length;
        for(int k=0;k<=nums.length;k++){
            dfs(new ArrayList<>(),k,nums,0);
        }
        System.out.println(listall);
        return listall;
    }
    public void dfs(ArrayList<Integer> list,int k,int[] nums,int begin){
        if(list.size()==k){
            listall.add(new ArrayList<>(list));
            return;
        }
        for(int i=begin;i<nums.length;i++){
            list.add(nums[i]);
            dfs(list,k,nums,i+1);
            list.remove(list.size()-1);
        }
    }

}
```

#### 子集case2: 90 子集2

给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

输入: [1,2,2]
输出:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
说明：解集不能包含重复的子集。
```java
class Solution {
    List<List<Integer>>listall=new ArrayList<>();
    int len;
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        len=nums.length;
        Arrays.sort(nums);
        for(int k=0;k<=nums.length;k++){
            dfs(new ArrayList<>(),k,nums,0);
        }
        return listall;
    }
    public void dfs(ArrayList<Integer> list,int k,int[] nums,int begin){
        if(list.size()==k){
            listall.add(new ArrayList<>(list));
            return;
        }
        for(int i=begin;i<nums.length;i++){
            if(i>begin&&nums[i]==nums[i-1]){
                continue;
            }
            list.add(nums[i]);
            dfs(list,k,nums,i+1);
            list.remove(list.size()-1);
        }
    }
}

```

#### 字符串排列

输入一个字符串，打印出该字符串中字符的所有排列。

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

```java
class Solution {
    
    List<String>list=new ArrayList();
    public String[] permutation(String s) {
        if(s.length()==0){
            return null;
        }
        char[]d=s.toCharArray();
        dfs(d,0);
        return list.toArray(new String[list.size()]);

    }
    public void dfs(char []d,int start){
        if(d.length-1==start){
            String temp=String.valueOf(d);
                list.add(temp);   
        }
        HashSet<Character>set=new HashSet();
        for(int i=start;i<d.length;i++){
            if(set.contains(d[i]))
                continue;
            set.add(d[i]);
            swap(d,i,start);
            dfs(d,start+1);
            swap(d,i,start);
        }
    }
    public void swap(char[]d,int i,int j){
        char temp=d[i];
        d[i]=d[j];
        d[j]=temp;
    }
}
```

