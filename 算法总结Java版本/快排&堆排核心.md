### 快排堆排核心

### 数组中出现次数超过一半的数字

**题目描述**
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。

* 解法1：
```java
public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
        if(array.length==0){
            return 0;
        }
        int time=1;
        int res=array[0];
        for(int i=1;i<array.length;i++){
            if(time<0){
                res=array[i];
                time=1;
            }
            if(array[i]==res){
                time++;
            }else{
                time--;
            }
            
        }
        int result=0;
        if(check(array,res)){
            result=res;
        }
        return result;
        
    }
    public boolean check(int [] array,int res){
        int l=0;
        for(int i=0;i<array.length;i++){
            if(res==array[i]){
                l++;
            }
        }
        boolean flag=false;
        if(l*2>array.length){
            flag=true;
            
        }
        return flag;
    }
}
```
* 解法2:
```java
public int MoreThanHalfNum_Solution(int [] array) {
        if(array.length==0){
            return 0;
        }
        int start=0;
        int end=array.length-1;
        int mid=(start+end)/2;
        int index=part(array,start,end);
        while(index!=mid){
            if(index>mid){
                end=mid-1;
                index=part(array,start,end);
            }else{
                start=mid+1;
                index=part(array,start,end);
            }
        }
     
        int result=0;
        if(check(array,array[mid])){
            result=array[mid];
        }
        return result;
    } 
    public int part(int []a,int start,int end){
        int index=(int)(start+Math.random()*(end-start));
        int s=start-1;
        swap(a,index,end);
        for(int i=start;i<=end;i++){
            if(a[i]<=a[end]){
                s++;
                if(i>s){
                    swap(a,s,i);
                }
            }
        }
        return s;
    }
     
    public void swap(int []a,int i,int j){
        int temp=a[i];
        a[i]=a[j];
        a[j]=temp;
    }
```
****************
### 最小的K个数
**题目描述**
输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。
* 快排
```java
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
        ArrayList <Integer>list=new ArrayList();   
        if(k==0||k>input.length){
            return list;
        }
        int start =0;int end=input.length-1;
        int index=part(input,start,end);
        while(index!=k-1){
            if(index>k-1){
                index=part(input,start,index-1);
            }else{
                index=part(input,index+1,end);
            }
        }
         
        for(int i=0;i<k;i++){
            list.add(input[i]);
        }
        return list;
         
    }
    public int part(int []a,int start,int end){
        int index=(int)(start+Math.random()*(end-start));
        int s=start-1;
        swap(a,index,end);
        for(int i=start;i<=end;i++){
            if(a[i]<=a[end]){
                s++;
                if(i>s){
                    swap(a,s,i);
                }
            }
        }
        return s;
    }
     
    public void swap(int []a,int i,int j){
        int temp=a[i];
        a[i]=a[j];
        a[j]=temp;
         
    }
}
```
* 堆排序

```java
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
        ArrayList <Integer> list=new ArrayList();
        if(input.length==0||k>input.length){
            return list;
        }
        sort(input);
        for(int i=0;i<k;i++){
            list.add(input[i]);
        }
        return list;
    }
    
    public void sort(int [] d){
        
        int len=d.length-1;
        for(int i=len/2;i>=0;i--){
            heap(d,i,len);
        }
        for(int i=len;i>0;i--){
            swap(d,i,0);
            len--;
            heap(d,0,len);
        }
    }
  	//这里是构建最大堆；
    public void heap(int d[],int i,int len){
        int large=i;
        int a=2*i+1;
        int b=2*i+2;
        if(a<=len&&d[a]>d[large]){
            large=a;
        }
        if(b<=len&&d[b]>d[large]){
            large=b;
        }
        if(large!=i){
            swap(d,i,large);
            heap(d,large,len);
        }
    
    }
    
    public void swap(int d[],int i,int j){
        int temp=d[i];
        d[i]=d[j];
        d[j]=temp;
    }
}
```

* 堆排序变种
求最小K个数字；
首先对这K个数字构建最大堆；
后面的数字和堆顶的相比；若小于堆顶元素则堆顶元素被替换；否则跳过。
```java
public ArrayList<Integer> GetLeastNumbers_Solution(int[] array, int k) {
		ArrayList<Integer> list = new ArrayList();
		if (array.length == 0 || k > array.length||k==0) {
			return list;
		}

		int[] temp = new int[k];
		for (int i = 0; i < k; i++) {
			temp[i] = array[i];
		}
		for (int i = (temp.length / 2); i >= 0; i--) {
			heap(temp, i, temp.length-1);
		}
		for (int i = k; i < array.length; i++) {
			if (array[i] < temp[0]) {
				temp[0] = array[i];
				heap(temp, 0, temp.length-1);
			} else {
				continue;
			}
		}
		for (int i = 0; i < temp.length; i++) {
			list.add(temp[i]);
		}
		return list;
	}
```

