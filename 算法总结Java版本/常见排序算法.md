* 常见排序算法

#### 1 冒泡排序

****************
代码思路：

 - 冒泡排序的是将相邻的两个依次进行比较这样一轮下来可以选出最小的或者最大的；
 - 总共需要进行length-1轮循环，因为，每一轮确定一个数，当length-1个数确定之后，最后一个也就确定了；
 - 然后是内层循环一共length个数，两两之间比较，只需要进行length-1次比较就可以了，又因为每一轮循环之后都有1个数已经排序好了，所以每一轮都需要少比较一次。

java代码实现如下：

```java
	public int[] sort(int[] a) {
		int flag;

		for (int i = 0; i < a.length - 1; i++) {
			for (int j = 0; j < a.length - i - 1; j++) {
				if (a[j] > a[j + 1]) {
					flag = a[j];
					a[j] = a[j + 1];
					a[j + 1] = flag;
				}
			}
		}
		return a;
	}
```
#### 2 选择排序
****************
代码思路：
* 选择排序是首先固定第一个最小的；
* 然后依次和后面的比较求出最小的下标；
* 接着就是将最小的下标和第一个交换。
* 每次排好一个，也就是每次比较都会少比较一次。
* 需要注意的是这里的第一个是指未排序的数字的第一个。
```java
	public static int[] ss(int[] a) {

		for (int i = 0; i < a.length - 1; i++) {
			int min = i;
			for (int j = i + 1; j < a.length; j++) {
				if (a[min] > a[j]) {
					min = j;
				}
			}

			if (min != i) {
				int flag = a[i];
				a[i] = a[min];
				a[min] = flag;
			}
		}
		return a;
	}
```
#### 3 快速排序
****************
快速排序的思想就是将一个值放到正确的位置。
* 随机选取一个数字，将这个数字摆放正确，然后类似的将这个数字的左右同样处理。
* 这里主要是partition 将key放到最后，然后对序列进行扫描，将小的放在前面，大的放在后面。
* 其中swap是将数组中的两个数进行交换。
* 时间复杂度：最佳：O(nlogn)；最差：O(n^2)
```java
public static int[] QuickSort(int[] array, int start, int end) {
		if (array.length < 1 || start < 0 || end >= array.length || start > end)
			return null;
		int index = partition(array, start, end);
		if (index > start)
			QuickSort(array, start, index - 1);
		if (index < end)
			QuickSort(array, index + 1, end);
		return array;
	}

	public static int partition(int[] array, int start, int end) {
		int index = (int) (start + Math.random() * (end - start + 1));

		int small = start - 1;
		swap(array, index, end);
		for (int i = start; i <= end; i++)
			if (array[i] <= array[end]) {
				small++;
				if (i > small)
					swap(array, i, small);
			}
		return small;
	}

	public static void swap(int[] array, int i, int j) {
		int temp = array[i];
		array[i] = array[j];
		array[j] = temp;
	}
```
#### 4 堆排序
**************
* 堆排序的思路很简单，这里以构建最大堆，也就是升序为例子；
* 针对每个非叶子节点进行heap，排成最大堆；
* 将头和尾进行swap，然后去掉最后一个，这是最大堆被打乱，再次heap；
* 重复上面操作即可。
* 时间复杂度：都是O(nlogn)
```java
	public int[] sort(int[] sourceArray) throws Exception {
		// 对 arr 进行拷贝，不改变参数内容
		int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

		int len = arr.length;

		buildMaxHeap(arr, len);

		for (int i = len - 1; i > 0; i--) {
			swap(arr, 0, i);
			len--;
			heapify(arr, 0, len); 
		}
		return arr;
	}

	private void buildMaxHeap(int[] arr, int len) {
		for (int i = (len / 2); i >= 0; i--) {
			heapify(arr, i, len);
		}
	}

	private void heapify(int[] arr, int i, int len) {
		int left = 2 * i + 1;
		int right = 2 * i + 2;
		int largest = i;

		if (left < len && arr[left] > arr[largest]) {
			largest = left;
		}

		if (right < len && arr[right] > arr[largest]) {
			largest = right;
		}

		if (largest != i) {
			swap(arr, i, largest);
			heapify(arr, largest, len);
		}
	}

	private void swap(int[] arr, int i, int j) {
		int temp = arr[i];
		arr[i] = arr[j];
		arr[j] = temp;
	}
```
#### 5 归并排序
************
* 下面的代码是逆序对的代码；但是其实也是归并排序；
* 只不过在归并排序中穿插了统计；
* 归并排序主要为分治思想。
* 时间复杂度：最佳-平均-最坏：O(nlogn)	
```java
public class Solution {
    int sum=0;
    public int InversePairs(int [] array) {
        if(array.length==0){
            return 0;
        }
        int start=0;
        int end=array.length-1;
        divide(array,start,end);
        return sum;
    }
    public void divide(int []array,int start,int end){
       if(start==end) {
					return;
				}
        
        int mid=(start+end)/2;
        divide(array,start,mid);
        divide(array,mid+1,end);
        merge(array,start,mid,end);
    }
    public void merge(int []array,int start,int mid,int end){
        
        int i=start;
        int j=mid+1;
        int []temp=new int[end-start+1];
        int k=0;
        while(i<=mid&&j<=end){
            if(array[i]<array[j]){
                temp[k++]=array[i++];
            }else{
                temp[k++]=array[j++];
                //array[i]>array[j];那么array[i]到array[mid]的都大于array[j]
                sum=(sum+mid-i+1)%1000000007;
            }
        }
        while(i<=mid){
            temp[k++]=array[i++];
        }
        while(j<=end){
            temp[k++]=array[j++];
        }
        for(int l=0;l<temp.length;l++){
            array[start+l]=temp[l];
        }
    }
}
```