* 二叉树
* [序列化二叉树](#1)
* [二叉搜索树的第k个结点](#2)
* [把二叉树打印成多行](#3)
*  [对称的二叉树&镜像2叉树](#4)
* [二叉树的下一个结点](#5)
* [二叉搜索树与双向链表](#6)
* [二叉树中和为某一值的路径](#7)
* [二叉搜索树的后序遍历序列](#8)
* [树的子结构](#9)
* [重建二叉树](#10)
* [平衡二叉树](#11)
* [二叉树的最近公共祖先](#12)
* [二叉树展开为链表](#13)
* [验证二叉排序树](#14)
* [二叉树遍历-前中后层次](#15)
* 二叉树最大路径和
**********
<h4 id="1">序列化二叉树</h4>

* 序列化就是简单的前序遍历；
* 反序列化是#返回null；不是则创建节点；
```java
public class Solution {
    public StringBuffer sb=new StringBuffer();
    String Serialize(TreeNode root) {
        if(root==null){
            sb.append("#,");
            return sb.toString();
        }
        sb.append(root.val+",");
        Serialize(root.left);
        Serialize(root.right);
        return sb.toString();

  }
    int index=-1;
    TreeNode Deserialize(String str) {
        TreeNode node=null;
        if(str.isEmpty()){
            return node;
        }
        index++;
        String [] d=str.split(",");
        if(!d[index].equals("#")){
            node=new TreeNode(Integer.valueOf(d[index]));
            node.left=Deserialize(str);
            node.right=Deserialize(str);
        }
        return node;
       
  }
}
```
*****************
<h4 id="2">二叉搜索树的第k个结点</h4>

* 采用list记录所有的节点；然后返回第k个；
```java
mport java.util.ArrayList;
public class Solution {
    ArrayList<TreeNode> list=new ArrayList();
    TreeNode KthNode(TreeNode pRoot, int k)
    {
        if(pRoot==null){
            return null;
        }
      
        KthNode(pRoot.left,k);
        list.add(pRoot);
        KthNode(pRoot.right,k);
        if(k==0||k>list.size()){
            return null;
        } 
        return list.get(k-1);  
    }
}
```
*********
<h4 id="3">把二叉树打印成多行</h4>

从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。
```java
import java.util.*;
public class Solution {
    ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
        ArrayList<ArrayList<Integer>> listall=new ArrayList();
        LinkedList <TreeNode>q=new LinkedList();
        if(pRoot==null){
            return listall;
        }
        q.offer(pRoot);
        
        while(q.size()!=0){
            ArrayList <Integer>list=new ArrayList();
            int l=0;
            int r=q.size();
            while(l++<r){
                TreeNode temp=q.poll();
                list.add(temp.val);
                if(temp.left!=null){
                    q.offer(temp.left);
                }
                if(temp.right!=null){
                    q.offer(temp.right);
                }
            }
            listall.add(list);
        }
        return listall;
    
    }
    
}
```
***************************
<h4 id="4">对称的二叉树&镜像二叉树</h4>

请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。

```java
public class Solution {
    boolean isSymmetrical(TreeNode pRoot)
    {
        boolean flag=dc(pRoot,pRoot);
        return flag;
    }
    public boolean dc(TreeNode t1,TreeNode t2){
        
        if(t1==null&&t2==null){
            return true;
        }
        if(t1==null||t2==null){
            return false;
        }
        if(t1.val!=t2.val){
            return false;
        }
                
        return dc(t1.left,t2.right)&&dc(t1.right,t2.left);
    }
}
```
镜像二叉树
```java
    public TreeNode mirrorTree(TreeNode root) {
        if(root==null)
            return null;
        
        TreeNode temp=root.left;
        root.left=root.right;
        root.right=temp;
        mirrorTree(root.left);
        mirrorTree(root.right);
        return root;

    }
```
*******************
<h4 id="5">二叉树的下一个结点</h4>

给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
* 这个节点存在右子节点则这个右子节点的最左下的节点是下一个；
* 若是没有右子树，则寻找该节点的父节点并且使得这个节点是其父节点的左子节点，返回其父节点。

```java
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode)
    {
        if(pNode==null){
            return null;
        }
        
        if(pNode.right!=null){
            pNode=pNode.right;
            while(pNode.left!=null){
                pNode=pNode.left;
            }
            return pNode;
        }else{
            while(pNode.next!=null&&pNode.next.left!=pNode){
                pNode=pNode.next;
            }
            return pNode.next;
            
        }
    }
}
```


<h4 id="6">二叉搜索树与双向链表</h4>

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

* realhead当作头；head用来进行遍历；
* 就是中序遍历中串插链表的构建;
```java
public class Solution {
    
    TreeNode head=null;
    TreeNode realhead=null;
    public TreeNode Convert(TreeNode pRootOfTree) {
        if(pRootOfTree==null){
            return null;
        }
        Convert(pRootOfTree.left);
        if(head==null){
            head= pRootOfTree;
            realhead= pRootOfTree;
        }else{
            head.right= pRootOfTree;
            pRootOfTree.left=head;
            head= pRootOfTree;
        }
        Convert(pRootOfTree.right);
        return realhead;
        
    }
}
```
**************
<h4 id="7">二叉树中和为某一值的路径</h4>

输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)
* 采用先序遍历；
```java
public class Solution {
    ArrayList <ArrayList<Integer>> listall=new ArrayList();
    ArrayList <Integer>list=new ArrayList();
    public ArrayList<ArrayList<Integer>> FindPath(TreeNode root,int target) {
        if(root==null){
            return listall;
        }
        target-=root.val;
        list.add(root.val);
        if(target==0&&root.left==null&&root.right==null){
            listall.add(new ArrayList(list));
        }
        FindPath(root.left,target);
        FindPath(root.right,target);
        list.remove(list.size()-1);
        return listall;
    }
}
```
******************
<h4 id="8">二叉搜索树的后序遍历序列</h4>

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。

* 二叉排序树的左<根<右
```java
public class Solution {
    public boolean VerifySquenceOfBST(int [] sequence) {
        
        if(sequence.length==0){
            return false;
        }
        int start=0;
        int end=sequence.length-1;
        
        boolean flag=hx(sequence,start,end);
        return flag;
    }
    public boolean hx(int []d,int start,int end){
        
        if(start>=end){
            return true;
        }
        int rootvalue=d[end];
        int i=start;
        for(;i<end;i++){
            if(d[i]>rootvalue){
                break;
            }
        }
        int j=i;
        for(;j<end;j++){
            if(d[j]<rootvalue){
                return false;
            }
        }
        
        boolean left=true;
        if(i>start){
            left=hx(d,start,i-1);
        }
        boolean right=true;
        if(i<end){
            right=hx(d,i,end-1);
        }
        
        return left&&right;
    }
}
```
*****************
<h4 id="9">树的子结构</h4>

输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

```java
public class Solution {
    public boolean HasSubtree(TreeNode root1,TreeNode root2) {
        if(root1==null||root2==null){
            return false;
        }
        boolean flag=false;
        if(root1.val==root2.val){
            flag=test(root1,root2);
        }
        if(!flag){
            flag=HasSubtree(root1.left,root2);
        }
        if(!flag){
            flag=HasSubtree(root1.right,root2);
        }
        return flag;
        
    }
    public boolean test(TreeNode root1,TreeNode root2){
        
        if(root2==null){
            return true;
        }
        if(root1==null){
            return false;
        }
        if(root1.val!=root2.val){
            return false;
        }
        return test(root1.left,root2.left)&&test(root1.right,root2.right);
    }
}
```
******************
<h4 id="10">重建二叉树</h4>

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

```java
public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        if(pre.length==0){
            return null;
        }
        int rootvalue=pre[0];
        int i=0;
        for(;i<in.length;i++){
            if(rootvalue==in[i]){
                break;
            }
        }
        TreeNode root=new TreeNode(rootvalue);
        
        root.left=reConstructBinaryTree(s1(pre,1,i+1),s1(in,0,i));
        root.right=reConstructBinaryTree(s1(pre,i+1,pre.length),s1(in,i+1,in.length));
        return root;
        
    }
    public int []s1(int []d,int s,int e){
        int []c=new int[e-s];
        int j=0;
        for(int i=s;i<e;i++){
            c[j++]=d[i];
        }
        return c;
        
    }
}
```


<h4 id="11">平衡二叉树&二叉树深度</h4>

```java
public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
        boolean flag=false;
        if(deep(root)!=-1){
            flag=true;
        }
        return flag;
    }
    public int deep(TreeNode t){
        
        if(t==null){
            return 0;
        }
        int left=deep(t.left);
        if(left==-1){
            return -1;
        }
        int right=deep(t.right);
        if(right==-1){
            return -1;
        }
        return Math.abs(right-left)>1?-1:Math.max(left,right)+1;
    }
}
```
二叉树深度
```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null){
            return 0;
        }
        int left=maxDepth(root.left);
        int right=maxDepth(root.right);
        return Math.max(left,right)+1;
    }
}
```
****************
<h4 id="12">二叉树的最近公共祖先</h4>

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200419213351844.png)

 

示例 1:

输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。

*  分别求解根节点到其中一个值的路径；这样形成两条路径；
* 求出最后一个相等的节点就是公共节点；
```java
class Solution {
    ArrayList <TreeNode>list1=new ArrayList();

   public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
		ArrayList<TreeNode> l1 = new ArrayList();
		ArrayList<TreeNode> l2 = new ArrayList();
		
		find(root, p, l1);
	    find(root, q, l2);
	    
        if(l1.size()==0&&l2.size()==0){
            return null;
        }
        
        int i=0;int j=0;
        TreeNode temp=null;
        while(i<l1.size()&&j<l2.size()){
            if(l1.get(i).val==l2.get(j).val){
                temp=l1.get(i);
                i++;j++;
                
            }else{
                break;
            }
        }
        
        if(i==l1.size()){
            temp=l1.get(i-1);
        }
        if(j==l2.size()){
            temp=l2.get(j-1);
        }
		return temp;
	}

	public void find(TreeNode root, TreeNode p, ArrayList<TreeNode> l1) {

		if (root == null) {
			return;
		}
		list1.add(root);
		if (root.val == p.val) {
			for(int i=0;i<list1.size();i++) {
				l1.add(list1.get(i));
			}
		}
		find(root.left, p, l1);
		find(root.right, p, l1);
		list1.remove(list1.size() - 1);
	}
}
```
***************
<h4 id="13">二叉树展开为链表</h4>


给定一个二叉树，原地将它展开为链表。

例如，给定二叉树


   1
   /  \\
  2   5
 / \    \\
3   4   6
将其展开为：

1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6

* 其实这里不应该叫 二叉树展开为链表 ；应该叫二叉树展开为只有右节点的二叉树；
* 也就是将他按照先序遍历展开，然后左节点为null右节点为先序顺序；

```java
class Solution {
    TreeNode head=null;
    public void flatten(TreeNode root) {
           if (root == null) {
			return;
		}
		flatten(root.right);
		flatten(root.left);
		if (head == null) {
			head = root;
		} else {
			root.right = head;
            root.left=null;
			head = root;
		}
    }  
}
```
******
<h4 id="14">验证二叉排序树</h4>

```java
class Solution {
    ArrayList <Integer>list=new ArrayList();
    public boolean isValidBST(TreeNode root) {
        if(root==null){
            return true;
        }
        in(root);
        boolean flag=true;
        for(int i=0;i<list.size()-1;i++){
            if(list.get(i)>=list.get(i+1)){
                flag=false;
            }
        }
        return flag;

    }
    public void in(TreeNode t){
        if(t==null){
            return;
        }
        in(t.left);
        list.add(t.val);
        in(t.right);

    }
}
```
***********
<h4 id="15">二叉树遍历</h4>
* 前序遍历

* 根左右；当前节点是否为空，不空则添加，（将该节点入栈），再访问左节点重复判断是否为空，不空添加入栈，空出栈一个元素访问右节点；再重复。
```java
class Solution {
    ArrayList <Integer> list=new ArrayList();
    //解法一
    public List<Integer> preorderTraversal1(TreeNode root) {
        if(root!=null){
            list.add(root.val);
            preorderTraversal1(root.left);
            preorderTraversal1(root.right);
        }
        return list;

    }
	//解法二
    public List<Integer> preorderTraversal(TreeNode root) {
        Stack <TreeNode>stack=new Stack();
        TreeNode t=root;

        while(t!=null||!stack.isEmpty()){
            if(t!=null){
                list.add(t.val);
                stack.push(t);
                t=t.left;
            }else{
                TreeNode temp=stack.pop();
                t=temp.right;
            }
        }
        return list;
    }
}
```
* 中序遍历
```java
class Solution {
    ArrayList <Integer>list=new ArrayList();
    //解法一
    public List<Integer> inorderTraversal1(TreeNode root) {
        
        if(root!=null){
            inorderTraversal1(root.left);
            list.add(root.val);
            inorderTraversal1(root.right);
        }
        return list;
    }
	//解法二
    public List<Integer> inorderTraversal(TreeNode root) {
        Stack <TreeNode> stack=new Stack();
        TreeNode t=root;
        while(t!=null||!stack.isEmpty()){
            if(t!=null){
                stack.push(t);
                t=t.left;
               
            }else{
                TreeNode temp=stack.pop();
                list.add(temp.val);
                t=temp.right;
            }
        }
        return list;

    }
}
```

* 后序遍历
* 这里采用注释和注释上面一行一样；同时改变while中stack就行了。

```java
class Solution {
//解法一
    public List<Integer> postorderTraversal(TreeNode root) {
        LinkedList <TreeNode>stack1=new LinkedList();
        Stack <TreeNode>stack=new Stack();  
        LinkedList <Integer> list=new LinkedList();
        if(root==null){
            return list;
        }
        stack.push(root);
        // stack1.add(root);
        while(!stack.isEmpty()){
            TreeNode temp= stack.pop();
            // TreeNode temp=stack1.pollLast();
            list.addFirst(temp.val);
            if(temp.left!=null){
                stack.push(temp.left);
                // stack1.add(temp.left);
            }
            if(temp.right!=null){
                stack.push(temp.right);
                // stack1.add(temp.right);
            }
        }
        return list;

    }
    //解法二
      LinkedList <Integer> list=new LinkedList();
      public List<Integer> postorderTraversal1(TreeNode root) {
        if(root==null){
            return list;
        }
        postorderTraversal1(root.left);
        postorderTraversal1(root.right);
        list.add(root.val);
        return list;

    }
}  
```
* 层次遍历

```java
import java.util.*;
public class Solution {
    public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {
        
        ArrayList<Integer> list=new ArrayList();
        if(root==null){
            return list;
        }
        LinkedList <TreeNode>q=new LinkedList();
        q.offer(root);
        while(q.size()!=0){
            TreeNode temp= q.poll();
            list.add(temp.val);
            
            if(temp.left!=null){
                q.offer(temp.left);
            }
            if(temp.right!=null){
                q.offer(temp.right);
            }
        }
        return list;
        
    }
}

```

* 二叉树最大路径和

```java

public class Solution {
 
    int res=Integer.MIN_VALUE;
    public int maxPathSum (TreeNode root) {
        // write code here
        if(root==null){
            return 0;
        }
        check(root);
        return res;
    }

    public int check(TreeNode root){
        if(root==null){
            return 0;
        }
        int lm=Math.max(check(root.left),0);
        int rm=Math.max(check(root.right),0);
        int d=root.val+lm+rm;
        res=Math.max(res,d);
        return root.val+Math.max(lm,rm);
        
    }
}
```

