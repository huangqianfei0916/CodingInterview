#### [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)
整数数组 nums 按升序排列，数组中的值 **互不相同** 。
例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。
```cpp
class Solution {
public:
    int search(vector<int>& vec, int target) {
        int start = 0;
        int end = vec.size() - 1;
        int flag = -1;
        while (start <= end){
            int mid = (start + end) / 2;

            if (target == vec[mid]) {
                flag = mid;
            }

            if (vec[mid] >= vec[start]) {
                if (target >= vec[start] && target < vec[mid]) {
                    end = mid - 1;
                } else {
                    start = mid + 1;
                }
            } else {
                if (target > vec[mid] && target <= vec[end]) {
                    start = mid + 1;
                } else {
                    end = mid - 1;
                }
            }

        }

        return flag;
    }
};
```
#### [81. 搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/)
已知存在一个按非降序排列的整数数组 nums ，数组中的值**不必互不相同**。
给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。
```cpp
class Solution {
public:
    bool search(vector<int>& vec, int target) {
        int l = 0;
        int r = vec.size() - 1;
        int flag = false;
        while (l <= r) {
            while (l < r && vec[l] == vec[l + 1]) {
                ++l;
            }
            while (l < r && vec[r] == vec[r - 1]) {
                --r;
            }
            int mid = (l + r) / 2;
            if (target == vec[mid]) {
                return true;
            }

            if (vec[mid] >= vec[l]) {
                if (target < vec[mid] && target >= vec[l]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } else {
                if (target > vec[mid] && target <= vec[r]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
        return false;
    }
};
```
#### [面试题 10.03. 搜索旋转数组](https://leetcode.cn/problems/search-rotate-array-lcci/)
和81题唯一的区别就是输出最左边的目标值
```cpp
class Solution {
public:
    int search(vector<int>& vec, int target) {

        if (vec[0] == target) {
            return 0;
        }

        int l = 0;
        int r = vec.size() -1;
        int flag = -1;

        while (l <= r) {
            int mid = (l + r) / 2;
            if (vec[mid] == target) {
                if (mid > 0 && vec[mid] != vec[mid - 1] || mid == 0) {
                    return mid;
                } else {
                    r = mid - 1;
                }

            } else if (vec[mid] > vec[l]) {
                if (target < vec[mid] && target >= vec[l]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } else if (vec[mid] < vec[l]){
                if (target > vec[mid] && target <= vec[r]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            } else {
                ++l;
            }
        }
        return flag;
    }
};
```
#### [153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)
已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 **旋转** 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7], 旋转后 [4,5,6,7,0,1,2] 
给你一个元素值 **互不相同** 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。
```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        
        int l = 0;
        int r = nums.size() - 1;

        while (l<=r) {
            if (l == r) {
                return nums[l];
            }
            int mid = (l + r) / 2;
            if (nums[mid] > nums[r]) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        return -1;

    }
};
```
#### [154. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/) & [剑指 Offer 11. 旋转数组的最小数字](https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)
已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 **旋转** 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7]
给你一个可能存在 **重复** 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。
```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        int l = 0;
        int r = nums.size() - 1;

        while (l <= r) {
            if (l == r) {
                return nums[l];
            }
            int mid = (l + r) / 2;

            if (nums[mid] > nums[r]) {
                l = mid + 1;
            } else if (nums[mid] < nums[r]) {
                r = mid;
            } else {
                --r;
            }
        }
        return -1;
    }
};
```
#### [剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)
统计一个数字在排序数组中出现的次数。
**输入:** nums = [5,7,7,8,8,10], target = 8 **输出:** 2
```cpp
class Solution {
public:
    int get_first(vector<int>& vec, int target) {
        int l = 0;
        int r = vec.size() - 1;

        while (l <= r) {
            int mid = (l + r) / 2;
            if (vec[mid] == target) {
                if (mid > 0 && vec[mid] != vec[mid - 1] || mid == 0) {
                    return mid;
                } else {
                    r = mid - 1;
                }

            } else if(target > vec[mid]) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return -1;
    }

    int get_last(vector<int>& vec, int target) {
        int l = 0;
        int r = vec.size() - 1;

        while (l <= r) {
            int mid = (l + r) / 2;
            
            if (vec[mid] == target) {
                if (mid < vec.size() - 1 && vec[mid] != vec[mid + 1] || mid == vec.size() - 1) {
                    return mid;
                } else {
                    l = mid + 1;
                }

            } else if(target > vec[mid]) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return -1;
    }
    int search(vector<int>& nums, int target) {
        int first_index = get_first(nums, target);
        int last_index = get_last(nums, target);

        int res = 0;
        if (first_index != -1 && last_index != -1) {
            res = last_index - first_index + 1;
        }
        
        return res;
    }
};
```
#### [69. x 的平方根](https://leetcode.cn/problems/sqrtx/)
```cpp
class Solution {
public:
    int mySqrt(int x) {
        int l = 0;
        int r = x;

        while (l <= r) {
            int mid = (l + r) / 2;
            long long num = (long long)mid * mid;
            if (num == x) {
                return mid;
            }
            if (num > x) {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        return r;

    }
};
```
