**组合问题**

- 组合问题是从数组中选取一些数，构成集合（每个集合没有明确的大小）；
- 组合涉及到原始数组是否重复（先sort，再判断nums[i] == nums[i - 1]），以及每个元素是否可以重复选用；

**排列问题**

- 排列问题是将数组中数字进行不同顺序的排列，构成不同的集合（每个集合的大小是相等的）；
- 排列同样涉及到原始数组是否重复（处理同组合），以及每个元素是否可以重复选用(需要新增vis数组，因为排列每次从0开始)；
## leetcode-39 - 组合1
给你一个 **无重复**元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。
candidates 中的 同一个 数字可以 **无限制重复**被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 
```cpp
class Solution {
    public:
    vector<vector<int> > vec_all;
    vector<int> vec;
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        if (candidates.size() == 0) {
            return vec_all;
        }
        dfs(candidates, target, 0);
        return vec_all;
        
    }
    
    void dfs(vector<int> candidates, int target, int begin) {
        if (target == 0) {
            vec_all.push_back(vec);
        }
        
        if (target < 0) {
            return;
        }
        
        for (int i = begin; i < candidates.size(); ++i) {
            
            vec.push_back(candidates[i]);
            dfs(candidates, target - candidates[i], i);
            vec.pop_back();
        }
    }
};
```
## leetcode-40 组合2
给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的每个数字在每个组合中只能**使用 一次 **。
```cpp
class Solution {
public:
    vector<vector<int> > vec_all;
    vector<int> vec;
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        if (candidates.size() == 0) {
            return vec_all;
        }
        sort(candidates.begin(), candidates.end());
        dfs(candidates, target, 0);
        return vec_all;

    }

    void dfs(vector<int> candidates, int target, int begin) {
        if (target == 0) {
            vec_all.push_back(vec);
            return;
        }

        if (target < 0) {
            return;
        }

        for (int i = begin; i < candidates.size(); ++i) {

            if (i > begin && candidates[i] == candidates[i - 1]){
                continue;
            }
            vec.push_back(candidates[i]);
            dfs(candidates, target - candidates[i], i + 1);
            vec.pop_back();
        }

    }
};
```
## leetcode216-组合3
找出所有相加之和为 n_ _的 k** **个数的组合，且满足下列条件：

- 只使用数字1到9
- 每个数字 **最多使用一次** 
```cpp
class Solution {
public:

    vector<vector<int>> vec_all;
    vector<int> vec_list;
    void dfs(vector<int>& vec, int begin, int len, int k, int n) {
        if (vec_list.size() == k && n == 0) {
            vec_all.push_back(vec_list);
            return;
        }

        for (int i = begin; i < vec.size(); ++i) {
            vec_list.push_back(vec[i]);
            dfs(vec, i + 1, len, k, n - vec[i]);
            vec_list.pop_back();
        }

    }
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9};
        int len = vec.size();
        dfs(vec, 0, len, k, n);
        return vec_all;

    }
};
```
## leetcode-46 排列1
给定一个不含重复数字的数组 nums ，返回其 _所有可能的全排列_ 。你可以 **按任意顺序** 返回答案。
**这里的vis是为了避免重复使用**
```cpp
class Solution {
public:
    vector<vector<int> > vec_all;
    vector<int> vec;
    vector<bool> vis;
    vector<vector<int>> permute(vector<int>& nums) {
        if (nums.size() == 0) {
            return vec_all;
        }
        for (int i = 0; i < nums.size(); ++i) {
            vis.push_back(false);
        }
        dfs(nums);
        return vec_all;
    }

    void dfs(vector<int> nums) {
        if (vec.size() == nums.size()) {
            vec_all.push_back(vec);
            return;
        }

        for (int i = 0; i < nums.size(); ++i) {
            if (vis[i]) {
                continue;
            }
            vec.push_back(nums[i]);
            vis[i] = true;
            dfs(nums);
            vis[i] = false;
            vec.pop_back();
        }

    }
};
```
## leetcode-47 排列2
给定一个可包含重复数字的序列 nums ，_**按任意顺序**_ 返回所有不重复的全排列。
```cpp
class Solution {
public:
    vector<vector<int>> vec_all;
    vector<int> vec;
    vector<bool> vis;
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        if (nums.size() == 0) {
            return vec_all;
        }
        for (int i = 0; i < nums.size(); ++i) {
            vis.push_back(false);
        }
        sort(nums.begin(), nums.end());
        dfs(nums);
        return vec_all;
    }

    void dfs(vector<int> nums) {
        if (vec.size() == nums.size()) {
            vec_all.push_back(vec);
            return;
        }

        for (int i = 0; i < nums.size(); ++i) {
            if (vis[i]) {
                continue;
            }
            if (i > 0 && vis[i - 1] && nums[i] == nums[i-1]) {
                continue;
            }
            vec.push_back(nums[i]);
            vis[i] = true;
            dfs(nums);
            vis[i] = false;
            vec.pop_back();
        }
    }
};
```
#### [剑指 Offer 17. 打印从1到最大的n位数](https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)
显然这是一个可以重复使用的全排列问题。
在两位数排列时候0-1组成1，0-2组成2，应该避免这种情况。
```cpp
class Solution {
public:
    vector<int> vec;
    vector<int> temp;
    vector<int> printNumbers(int n) {
        for (int i = 1; i <= n; ++i) {
            dfs(i);
        }
        return vec;
    }

    void dfs(int len) {
        if (temp.size() == len) {
            int sum = 0;
            for (auto item : temp) {
                sum +=  item * pow(10, len - 1);
                --len;
            }
            vec.push_back(sum);
            return;
        }
        for (int i = 0; i <= 9; ++i) {
            if (temp.size() == 0 && i == 0) {
                continue;
            }
            temp.push_back(i);
            dfs(len);
            temp.pop_back();
        }
    }
};
```
## leetcode-78 子集
给你一个整数数组 nums ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。
解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。
**输入：**nums = [1,2,3] **输出：**[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```cpp
class Solution {
public:
    vector<vector<int>> vec_all;
    vector<int> vec;
    vector<vector<int>> subsets(vector<int>& nums) {
        if (nums.size() == 0) {
            return vec_all;
        }
        for (int i = 0; i <= nums.size(); ++i) {
            dfs(nums, i, 0);
        }
        return vec_all;
    }

    void dfs(vector<int> nums, int k, int begin) {
        if (vec.size() == k) {
            vec_all.push_back(vec);
            return;
        }
        for (int i = begin; i < nums.size(); ++i) {

            vec.push_back(nums[i]);
            dfs(nums, k, i + 1);
            vec.pop_back();
        }
    }
};
```
## leetcode-90 [子集 II](https://leetcode.cn/problems/subsets-ii/)
给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。
示例 1：
输入：nums = [1,2,2] 输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
```cpp
class Solution {
public:
    vector<vector<int>> vec_all;
    vector<int> vec;
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        if (nums.size() == 0) {
            return vec_all;
        }
        sort(nums.begin(), nums.end());
        for (int i = 0; i <= nums.size(); ++i) {
            dfs(nums, i, 0);
        }
        return vec_all;
    }

    void dfs(vector<int> nums, int k, int begin) {
        if (vec.size() == k) {
            vec_all.push_back(vec);
            return;
        }

        for (int i = begin; i < nums.size(); ++i) {
            if (i > begin && nums[i] == nums[i - 1]){
                continue;
            }
            vec.push_back(nums[i]);
            dfs(nums, k, i + 1);
            vec.pop_back();
        }
    }
};
```
