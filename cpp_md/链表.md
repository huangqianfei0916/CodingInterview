## 链表反转
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
```
```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        
        ListNode* p = head;
        ListNode* pre = nullptr;
        head = nullptr;
        
        while (p != nullptr) {
            pre = p;
            p = p->next;
            pre->next = head;
            head = pre;
        }
        return head;
    }
};
```
## 链表反转2-leetcode92
反转指定区间链表；**输入：**head = [1,2,3,4,5], left = 2, right = 4 **输出：**[1,4,3,2,5]
```cpp
class Solution {
    public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        
        if (head->next == nullptr) {
            return head;
        }
        ListNode* h = new ListNode(0);
        h->next = head;
        ListNode* pre = h;
        
        for (int i = 1; i < left; ++i) {
            pre = pre->next;
        }
        ListNode* start = pre->next;
        ListNode* tail = start->next;
        
        for (int i = left; i < right; ++i) {
            start->next = tail->next;
            tail->next = pre->next;
            pre->next = tail;
            tail = start->next;
        }
        return h->next;
    }
};
```
## k个一组反转链表-leeetcode25
**输入：**head = [1,2,3,4,5], k = 2 **输出：**[2,1,4,3,5]
![image.png](https://cdn.nlark.com/yuque/0/2022/png/29253340/1656815761737-e67c2b3c-a10a-4cd0-81ba-f9bdca9a70ec.png#clientId=u5a7c4b2b-a3f8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=111&id=ucf9abf3f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=222&originWidth=542&originalType=binary&ratio=1&rotation=0&showTitle=false&size=80966&status=done&style=none&taskId=u8daec77e-5753-4bec-90b7-a5a61cd01a8&title=&width=271)
```cpp
ListNode* reverseKGroup(ListNode* head, int k) {
    if (k == 1 || head->next == nullptr) {
        return head;
    }
    ListNode* p = head;
    int len = 0;
    while (p != nullptr) {
        ++len;
        p = p->next;
    }
    int n = len / k;

    int start = 1;
    int end = start + k - 1;
    while (n != 0) {
        head = reverseBetween(head, start, end);
        start = end + 1;
        end = start + k - 1;
        --n;
    }
    return head;
}
```
## 链表排序
```python
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if (head == nullptr) {
            return head;
        }
        ListNode* f = devideList(head, nullptr);
        return f;

    }

    ListNode* devideList (ListNode* head, ListNode* tail) {
        if (head->next == tail) {
            head->next = nullptr;
            return head;
        }

        ListNode* slow = head;
        ListNode* fast = head;
        while (fast != tail) {
            slow = slow->next;
            fast = fast->next;
            if (fast != tail) {
                fast = fast->next;
            }
        }
        ListNode* mid = slow;
        ListNode* left = devideList(head, mid);
        ListNode* right = devideList(mid, tail);
        return mergeSortList(left, right);

    }

    ListNode* mergeSortList(ListNode* A, ListNode* B) {
        ListNode* head = new ListNode(0);
        ListNode* p = head;

        while(A != nullptr && B != nullptr) {
            if (A->val < B->val) {
                p->next = A;
                p = p->next;
                A = A->next;
            } else {
                p->next = B;
                p = p->next;
                B = B->next;
            }
        }
        if (A != nullptr) {
            p->next = A;
        }

        if (B != nullptr) {
            p->next = B;
        }
        return head->next;
    }
};
```
#### [剑指 Offer II 026. 重排链表](https://leetcode.cn/problems/LGjMqU/)
给定一个单链表 L 的头节点 head ，单链表 L 表示为：
 L0 → L1 → … → Ln-1 → Ln 
请将其重新排列后变为：
L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/29253340/1661869030409-e903656f-443f-4bb8-bb2d-be6f4c469286.png#clientId=ubd135ead-d03e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=111&id=u7f86d9ce&margin=%5Bobject%20Object%5D&name=image.png&originHeight=222&originWidth=422&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29771&status=done&style=none&taskId=ua1da1028-9391-44d7-a3d4-7100f229f72&title=&width=211)
```cpp
class Solution {
public:
    ListNode* getMid(ListNode* head) {
        ListNode* fast = head;
        ListNode* slow = head;
        if(fast) {
            fast = fast->next;
            if (fast) {
                fast = fast->next;
            }
        }
        while (fast) {
            fast = fast->next;
            slow = slow->next;
            if (fast) {
                fast = fast->next;
            }
        }
        return slow;
    }

    ListNode* reverse(ListNode* head) {
        ListNode* p = head;
        ListNode* q = head;
        head = nullptr;
        while (p) {
            q = p;
            p = p->next;
            q->next = head;
            head = q;
        }
        return head;
    }
    ListNode* merge(ListNode* root1, ListNode* root2) {
        ListNode* head = new ListNode(0);
        ListNode* p = head;
        int flag = 1;
        while (root1 != nullptr && root2 != nullptr) {
            if ((flag % 2) == 1) {
                p->next = root1;
                p = p->next;
                root1 = root1->next;
            } else {
                p->next = root2;
                p = p->next;
                root2 = root2->next;
            }
            ++flag;
        }
        if (root1) { p->next = root1; }
        if (root2) { p->next = root2; }
        return head->next;
    }
    void reorderList(ListNode* head) {

        ListNode* mid = getMid(head);
        ListNode* root2 = reverse(mid->next);

        mid->next = nullptr;
        ListNode* real_head = merge(head, root2);

        head = real_head;
        
    }
};
```
