## 整数拆分｜剪绳子-快速幂
给定一个正整数 n ，将其拆分为 k 个 **正整数** 的和（ k >= 2 ），并使这些整数的乘积最大化。
返回 _你可以获得的最大乘积_ 。
```cpp
class Solution {
public:
    int cuttingRope(int n) {
        if (n == 2) {
            return 1; 
        }
        if (n == 3){
            return 2;
        }
        int index = n % 3;
        int index2 = n / 3;
        
        if (index == 0) {
            return quick_pow(3, index2) % 1000000007;
        } else if (index == 1) {
            return quick_pow(3, index2 - 1) * 2 * 2 % 1000000007;
        } else {
            return quick_pow(3, index2) * 2 % 1000000007;
        }

    }

    long quick_pow(int x, int n) {
        long res = 1;
        long temp = x;
    
        while (n != 0) {
            if ((n % 2) == 1) {
                res *= temp;
                res = res % 1000000007;
                --n;
            } else {
                temp = temp * temp;
                temp = temp % 1000000007;
                n = n / 2;
            }
        }
        return res;
    }
};
```
## 股票买卖-哨兵
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int res = 0;
        int min_flag = prices[0];

        for (int i = 0; i < prices.size(); ++i) {
            if (prices[i] < min_flag) {
                min_flag = prices[i];
            }
            res = max(res, prices[i] - min_flag);
        }
        return res;
    }
};
```
