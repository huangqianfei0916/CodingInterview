## 时间复杂度o(n)
### [152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)
给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。
**子数组** 是数组的连续子序列。
```cpp
class Solution {
    public:
    int maxProduct(vector<int>& nums) {
        if (nums.size() == 0) {
            return 0;
        }
        
        int res = nums[0];
        int temp_max = nums[0];
        int temp_min = nums[0];
        
        for (int i = 1; i < nums.size(); ++i) {
            int temp = temp_max;
            temp_max = max(max(temp_max * nums[i], nums[i]), temp_min * nums[i]);
            temp_min = min(min(temp_min * nums[i], nums[i]), temp * nums[i]);
            
            res = max(res, temp_max);
        }
        return res;
    }
};
```
### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
**子数组 **是数组中的一个连续部分。
```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> dp(nums.size());
        int res = nums[0];
        dp[0] = nums[0];
        for (int i = 1; i < nums.size(); ++i) {
            dp[i] = max(dp[i - 1] + nums[i], nums[i]);
            res = max(dp[i], res);
        }
        return res;
    }
};
```
### [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。
```cpp
class Solution {
public:
    int rob(vector<int>& nums) {

        vector<int> dp(nums.size());
        dp[0] = nums[0];
        
        if (nums.size() > 1) {
            dp[1] = max(nums[0], nums[1]);
        }

        for (int i = 2; i < nums.size(); ++i) {
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
        }
        return dp[nums.size() - 1];
    }
};

// 若是环形
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 1) {
            return nums[0];
        } else if (nums.size() == 2) {
            return max(nums[0], nums[1]);
        }

        return max(rob1(nums, 0, nums.size() - 2), rob1(nums, 1, nums.size() - 1));

    }

    int rob1(vector<int>& nums, int start, int end) {

        int first = nums[start];
        int second = max(nums[start], nums[start + 1]);        

        for (int i = start + 2; i <= end; ++i) {
            int temp = second;
            second = max(second, first + nums[i]);
            first = temp;
        }
        return second;
    }
};
```
### [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
```cpp
class Solution {
public:
    int climbStairs(int n) {
        vector<long> dp(n + 1);
        dp[0] = 1;
        dp[1] = 2;
        for (int i = 1; i < n; ++i) {
            dp[i + 1] = dp[i] + dp[i - 1];
        }
        return dp[n - 1];
    }
};
```
## 时间复杂度o(n2)
### [139. 单词拆分](https://leetcode.cn/problems/word-break/)
给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。
注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。
```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        vector<bool> dp(s.size() + 1);
        dp[0] = true;
        for (int i = 1; i <= s.size(); ++i) {
            for (int j = 0; j < i; ++j) {
                string temp = s.substr(j, i - j);
                
                vector<string>::iterator it = find(wordDict.begin(), wordDict.end(), temp);
                if (dp[j] && it != wordDict.end()) {
                    dp[i] = true;
                    break;
                }
            }
        }
        
        return dp[s.size()];

    }
};
```
### [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)
**输入：**nums = [10,9,2,5,3,7,101,18] **输出：**4 **解释：**最长递增子序列是 [2,3,7,101]，因此长度为 4 。
定义 :dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取。
dp[i]=max(dp[j])+1,  其中0≤j<i且num[j]<num[i];
这样子dp数组就填充完毕了，求出其中最大值就是最终结果。
```cpp
class Solution {
    public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> dp(nums.size());
        int res = 0;
        for (int i = 0; i < nums.size(); ++i) {
            dp[i] = 1;
            for (int j = 0; j < i; ++j) {
                if (nums[i] > nums[j]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
            res = max(res, dp[i]);
        }
        return res;
    }
};
```
