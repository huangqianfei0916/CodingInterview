### [409. 最长回文串](https://leetcode.cn/problems/longest-palindrome/)（统计字符词频是偶数的个数，同时加1）
给定一个包含大写字母和小写字母的字符串 s ，返回 _通过这些字母构造成的 **最长的回文串**_ 。
**输入:**s = "abccccdd" **输出:**7 **解释:** 我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
```cpp
class Solution {
public:
    int longestPalindrome(string s) {
        map<char, int> char_map;

        // 智障写法
        // for (auto item : s) {
        //     if (s.find(item) != string::npos) {
        //         ++char_map[item];
        //     } else {
        //         char_map[item] = 1;
        //     }
        // }

        for (auto& item : s) {
            ++char_map[item];
        }
        
        int res = 0;
        for (auto& [key, value] : char_map) {
            if (value & 1) {
                ++res;
            }
        }
        return res == 0 ? s.size() : s.size() - res + 1;
    }
};
```
### [647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)
给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。
回文字符串 是正着读和倒过来读一样的字符串。子字符串 是字符串中的由连续字符组成的一个序列。
解析：
为什么有 2 * len - 1 个中心点？
aba 有5个中心点，分别是 a、b、c、ab、ba
abba 有7个中心点，分别是 a、b、b、a、ab、bb、ba
什么是中心点？
中心点即 left 指针和 right 指针初始化指向的地方，可能是一个也可能是两个
接下来只需要判断中心点，可以延伸出多少回文串
```cpp
class Solution {
public:
    int countSubstrings(string s) {
        int ans = 0;
        for (int i = 0; i < 2 * s.size() - 1; ++i) {

            int left = i / 2;
            int right = left + i % 2;
            while (left >= 0 && right < s.size() && s[left] == s[right]) {
                left--;
                right++;
                ans++;
            }
        }

    }
};
```
### [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)
**输入：**s = "babad" **输出：**"bab" **解释：**"aba" 同样是符合题意的答案。

- 中心扩散法
- 从第一个位置开始利用中心扩散记录最长，
- 每个位置扩散都有最长回文子串，更新记录最长的长度，和扩散的左边界，
- 扩散规则是分别while判断当前点和左右边届是否相等，相等，则边界移动，本次字串len++，
- 然后判断左右节点是否相等，相等则本次子串len+=2，
- 注意每次len置为1
- 最后根据记录的最长的len和对应的left求子串
```cpp
class Solution {
public:
    string longestPalindrome(string s) {

        int res_len = 0;
        int start_index = 0;
        for (int i = 0; i < s.size(); ++i) {
            
            int left = i - 1;
            int right = i + 1;
            int len = 1;

            while (left >= 0 && s[i] == s[left]) {
                ++len;
                --left;
            }

            while (right <= s.size() - 1 && s[right] == s[i]) {
                ++len;
                ++right;
            }

            while(left >= 0 && right <= s.size() - 1 && s[left] == s[right]) {
                len += 2;
                --left;
                ++right;
            }

            if (len > res_len) {
                res_len = len;
                start_index = left;
            }
            
        }
        return s.substr(start_index + 1, res_len);
    }
};
```
### [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)
给定一个字符串 s ，请你找出其中不含有重复字符的 **最长子串 **的长度。

- 用set记录无重复子串长度，
- 不包含则直接添加，并更新最长的长度，++i，
- 包含则开始从字符串起始位置删除元素，
```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        set<char> char_set;
        int max_len = 0;
        int k = 0;
        for (int i = 0; i < s.size(); ) {
            if (char_set.find(s[i]) == char_set.end()) {
                // 查不到
                char_set.insert(s[i]);
                ++i;
                int len = char_set.size();
                max_len = max(max_len, len);
            } else {
                char_set.erase(s[k++]);
            }
        }
        return max_len;

    }
};
```
#### [6166. 最大回文数字](https://leetcode.cn/problems/largest-palindromic-number/)
给你一个仅由数字（0 - 9）组成的字符串 num 。
请你找出能够使用 num 中数字形成的 **最大回文** 整数，并以字符串形式返回。该整数不含 **前导零** 。
```cpp
class Solution {
public:
    string largestPalindromic(string num) {
        int cnt[10] = {0};
        for (char c : num) cnt[c - '0']++;
        // ans 表示对应的部分中的前一半，ans2 是 ans 的倒序
        string ans, ans2;
        // 求回文串两边对应的部分
        for (int i = 9; i >= 0; i--) {
            // 已经枚举到了 0，但是之前从来没有加入过别的数字。此时加入 0 将会导致前导 0，因此直接结束。
            if (i == 0 && ans.empty()) break;
            // 在这部分中出现过的数必须出现偶数次
            int t = cnt[i] / 2;
            for (int j = 0; j < t; j++) ans.push_back(i + '0');
            cnt[i] -= t * 2;
        }
        ans2 = ans;
        reverse(ans2.begin(), ans2.end());
        // 看看是否还有剩下的数，可以作为中间单独的一个数字
        for (int i = 9; i >= 0; i--) if (cnt[i]) {
            // 此时 0 无需跳过，因为单独一个 0 是合法的答案
            ans.push_back(i + '0');
            break;
        }
        return ans + ans2;
    }
};
```
