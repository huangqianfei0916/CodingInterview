**2维动态规划的求解都是填充dp矩阵的过程，初始化矩阵的双边（初始条件），同时确定推理过程，填充整个矩阵，从而求解问题。**
## 最小路径之和
给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：一个机器人每次只能向下或者向右移动一步。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/29253340/1655039313614-7a87533d-a54a-4406-b4fd-d65cd487d296.png#clientId=u6012d5a3-f8e8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=121&id=ud330d47e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=242&originWidth=242&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22319&status=done&style=none&taskId=uef4c9597-dffc-4d27-9307-07afac2afa4&title=&width=121)

- base：dp[0] [0]=grid[0] [0];
- 递推
- i==0 时，dp[i] [j]=grid[i] [j]+dp[i] [j-1];
- j==0时，dp[i] [j]=grid[i] [j]+dp[i-1] [j];
- 其余，dp[i] [j]=grid[i] [j]+Math.min(dp[i-1] [j],dp[i] [j-1]);
```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int rows = grid.size();
        int cols = grid[0].size();
        vector<vector<int>> dp(rows, vector<int>(cols));

        dp[0][0] = grid[0][0];
        for (int i = 1; i < rows; ++i) {
            dp[i][0] = dp[i - 1][0] + grid[i][0]; 
        }

        for (int i = 1; i < cols; ++i) {
            dp[0][i] = dp[0][i - 1] + grid[0][i];
        }

        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                if (i == 0 || j == 0) {
                    continue;
                }
                dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return dp[rows - 1][cols - 1];
    }
};
```
## 最长公共子序列
给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。
一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/29253340/1655041670547-14da2a0c-89fb-4c57-aea1-f27394aa7693.png#clientId=u6012d5a3-f8e8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=120&id=ufaf03cdc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=139&originWidth=586&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8023&status=done&style=none&taskId=ua37440f0-f953-411a-a4c8-9b7cf334d37&title=&width=506)
```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int rows = text1.size();
        int cols = text2.size();
        vector<vector<int>> dp(rows + 1, vector<int>(cols + 1));
        for (int i = 0; i < dp.size(); ++i) {
            dp[i][0] = 0;
        }
        for (int i = 0; i < dp[0].size(); ++i) {
            dp[0][i] = 0;
        }

        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                if (text1[i] == text2[j]) {
                    dp[i + 1][j + 1] = dp[i][j] + 1;
                } else {
                    dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]);
                }
            }
        }
        return dp[rows][cols];
    }
};
```
## 最长公共子串|最长重复子数组
![image.png](https://cdn.nlark.com/yuque/0/2022/png/29253340/1655041730066-a5ac7bdd-a8ca-4b2f-b603-7a2e7123f0ae.png#clientId=u6012d5a3-f8e8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=317&id=u4210873a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=423&originWidth=603&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38835&status=done&style=none&taskId=u6c4cbe58-07fc-47d7-ab64-2d5ff9ee850&title=&width=452)
```cpp
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int len1 = nums1.size();
        int len2 = nums2.size();
        vector<vector<int>> dp(len1 + 1, vector<int>(len2 + 1));

        for (int i = 0; i < dp.size(); ++i) {
            dp[i][0] = 0;
        }

        for (int i = 0; i < dp[0].size(); ++i) {
            dp[0][i] = 0;
        }
        int res = 0;
        for (int i = 0; i < len1; ++i) {
            for (int j = 0; j < len2; ++j) {
                if (nums1[i] == nums2[j]) {
                    dp[i + 1][j + 1] = dp[i][j] + 1;
                } else {
                    dp[i + 1][j + 1] = 0;
                }
                res = max(res, dp[i + 1][j + 1]);
            }
        }
        return res;
    }
};
```
## 编辑距离
```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int len1 = word1.size();
        int len2 = word2.size();
        vector<vector<int>> dp(len1 + 1, vector<int>(len2 + 1));
        for (int i = 0; i < dp.size(); ++i) {
            dp[i][0] = i;
        }

        for (int i = 0; i < dp[0].size(); ++i) {
            dp[0][i] = i;
        }

        for (int i = 0; i < len1; ++i) {
            for (int j = 0; j < len2; ++j) {
                if (word1[i] == word2[j]) {
                    dp[i + 1][j + 1] = dp[i][j];
                } else {
                    dp[i + 1][j + 1] = min(dp[i][j] + 1, min(dp[i][j + 1], dp[i + 1][j]) + 1);
                }
            }
        }
        return dp[len1][len2];

    }
};
```
## 不同路径-leetcode62（从矩阵左上角到右下角的走法）
```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n));
        for (int i = 0; i < dp.size(); ++i) {
            dp[i][0] = 1;
        }

        for (int i = 0; i < dp[0].size(); ++i) {
            dp[0][i] = 1;
        }

        for (int i = 1; i < m; ++i) {
            for (int j = 1; j < n; ++j) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }

        return dp[m - 1][n - 1];
    }
};
```
